---
title: Kernel-Scheduling-Algorithm
date: 2021-04-19 18:30:52
tags: OS
---

## 操作系统调度算法介绍
### 为什么需要调度？
1. 操作系统需要充分利用系统的资源，资源的有效利用是让操作系统高效运行的重要基础。
2. 操作系统需要满足多个进程并发执行的目标。
3. 操作系统需要尽快响应用户。
### 调度指标有哪些？
- 性能：
  * 批处理任务：吞吐量，周转时间。
  * 交互式任务：响应时间。
- 非性能：
  * 公平性。
  * 资源利用率。
  * 实时任务：实时性。
  * 能耗。
尽管我们希望一个好的调度策略可以让所有的调度指标都好，但是事实上我们在提高一些指标的同时其他指标可能会受到影响，比如我们手机的省电模式下往往只让你使用有限的亮度或限制app使用数量，就是因为性能和能耗两个不同指标间存在冲突。

### 调度类型
* 调度内容： 任务调度，IO调度，内存调度，能耗感知调度。
* 调度场景：优先级调度，公平共享调度，实时调度，协同调度。
* 单核调度，多核调度。
### 有哪些任务调度算法？
#### 经典调度
  * FCFS（先来先服务）：维护一个任务队列，到来的任务push到队尾，每次调度从队首取任务执行，不支持抢占。
    * 优点：简单直观，对CPU密集型任务友好。
    * 缺点：对短任务不太友好，后来的短任务需要很长周转时间。
    * 缺点：对IO密集型任务不太友好，当IO到来时，主动放弃CPU资源的任务在之后IO请求返回的时候无法及时抢占CPU资源，必须等待，导致IO的性能很低。
  * SJF（最短任务优先）：在调度发生时选择运行时间最短的任务执行，不支持抢占。
    * 缺点：需要预知任务时间，常规情况难以预测。
    * 缺点：依赖任务到达时间，后到达的短任务仍然需要等待之前的长任务时间。
  * STJF（最短完成时间任务优先）：SJF的抢占版本。
    * 优点：短任务优先，响应时间快。
    * 缺点：长任务饥饿。由于那些短任务可抢占长任务CPU，这会导致大量的短任务可能让长任务无法及时占用CPU资源，那些后台执行的长任务将无法正常工作。
  * RR（时间片轮转）：每个任务定长时间片，每隔一个时间片检查一个任务是否时间片用完，用完则调度切换到队列的其他任务执行。之后当所有任务都执行完了，再重置时间片。
    * 优点：公平性强，不同类型任务之间都会执行一定较短时间，然后将CPU让给其他的任务。
    * 优点：响应时间较短。
    * 缺点：若时间片过长，则响应时间长，其他任务的等待时间也长;若时间片过短，上下文切换多，性能开销大。
    * 缺点：周转时间较长。
#### 优先级调度
  * MLQ（多级队列）：引入优先级的概念，不同级别的队列有不同的优先级，可以采用不同的调度策略，选择非空的最高优先级的队列的队首任务进行调度。
    * 优点：由于不同的队列可以有不同的策略，利于区分不同任务。
    * 缺点：低优先级队列上的任务容易饥饿。如果高优先级队列有大量的任务，则低优先级队列上的任务迟迟无法执行。
  * MLFQ（多级反馈队列）：多级队列+动态设置任务优先。级。评估任务的执行时间，判断长短任务，短任务最高优先级。每个队列的任务都有其最大运行时间，超时则任务降级（长任务容易降级）。给低优先级的任务更长的时间片，并定时将所有任务的优先级提高到最高，避免任务饥饿。
    * 优点：动态调整任务优先级，短任务优先执行，长任务不会饥饿。
    * 缺点：需要调参。比如任务提升优先级时间间隔过短，所有任务都留在最高优先级的队列中，退化成RR策略。提升优先级的时间间隔过长，低优先级的长任务无法得以执行。
#### 实时调度
  实时操作系统中考虑的依据不同，任务的完成时间有明确的上限，有确定性，可预测的任务时延。（此处不展开讲）
  * RM（速率单调）：速率越高意味着任务周期越短，截止时间越迫切，分配越高的优先级。支持抢占。有稳定的任务时延，不能满足对截止时间的要求。
  * EDF（最早截至时间优先）：将截止时间作为优先级衡量的依据。在CPU利用率<=1的前提下可以满足任务截止时间的要求。
#### 其他调度
  * BVT（借用虚拟时间）:任务通过降低有效虚拟时间来优先调度。
  …

#### Linux当前的调度算法有哪些？
  * O（N）（v<=2.4）
    * 基于RR策略。
    * 调度时会动态计算优先级并选用最高优先级任务调度。
    * 执行完的任务被移除，再次调度时放入队列尾。
    * 一个调度时间段，调度器会遍历队列并更新所有任务时间片，将它们剩余时间片的一半加入到下一个调度中。
    * 缺点：调度开销大。
    * 缺点：多核扩展性差。
  * O（1） （v==2.6.0）
    * 每个CPU一个激活队列和过期队列。每个激活队列和过期队列都是多级队列，通过位图可以以O（1）复杂度找到激活队列上第一个非空队列 上的第一个任务调度。
    * 调度开销小。
    * 保证交互式任务时延较小。
    * 缺点：使用静态时间片，调度时延依赖于任务数量。
    * 缺点：启发式算法判断任务类型过于复杂。
  * CFS（完全公平调度器）
    * 红黑树作为任务队列，虚拟时间作为索引，可以O（1）找到虚拟时间最小的任务，调度会选择虚拟时间最小的任务。
    * 调度周期内所有任务都会被执行一次，保证公平性。
    * 为任务分配动态时间片。每个调度周期内不同优先级的任务执行的物理时间有别，但增长的虚拟时间相同。
    * 阻塞唤醒的任务优先执行。
    * 用于调度非实时任务。
    * 调度策略： SCHED_OTHER， SCHED_BATCH，SCHED_IDLE。
  * RT（实时调度器）
    * 使用多级优先级队列，调度实时任务。
    * 调度策略： SCHED_FIFO， SCHED_RR。
  * DL（截止时间调度器）
    * 类似EDF调度策略。
    * 调度策略： SCHED_DEADLINE。