---
title: Transaction Isolation
date: 2021-10-31 11:33:58
tags: DB
hidden: true
---

# I(solation)

`隔离性` 决定了事务对其他用户以及系统的可见性。
`隔离性` 在乎的是多个事务在并发读写不会相互干扰。


### 隔离冲突
1. 脏读（写读冲突）：读到某个事务读取其他事务未提交的数据。
2. 脏写（写写冲突）：某个事务覆盖另一个事务未提交的数据。
3. 不可重复读（读写冲突）：事务中读取同一行数据获取多次得到不同的结果。（UPDATE）
4. 幻读：事务中两个相同查询获得的数据集合不同。（INSERT, DELETE）
5. 更新丢失（写冲突）：两个事务对同一个数据执行读-修改-写回，由于第二个写操作不包含第一个事务修改后的值，第二个读的数据属于快照读，最终会导致第一个事务的修改值丢失。
6. 写倾斜（写冲突）（属于幻读，属于广义的更新丢失）：两个事务对多个数据执行读-修改-写回，由于第一个写操作会修改第二个事务的读的数据，第二个读的数据属于快照读，最终会导致逻辑错误。

```
x := int[]{1, 2}

for i := 0; i < 2; i++ {
   go func() {
     if len(x) >= 2 {
        // danger!
        x = x[1:]
     }
   }()
}
fmt.Println(len(x)) // maybe 0
```

如何解决事务中的这些冲突？设置合理的隔离级别。
较弱的隔离级别有利于多事务的并发，但是可能会出现上述的冲突。
理论上，在不损害正确性的情况下，我们可以设置较低的隔离级别以获得更好的性能。选择决定于应用场景。

### 隔离级别

1. 未提交读
* 一个事务修改数据，如果该事务尚未提交，其他事务仍然可以读取该数据。
* 读：行级分享锁。
* 写：无。
* 优点：性能好。
* 缺点：`脏读`。

2. 提交读
* 一个事务修改数据，如果该事务尚未提交，其他事务不可以读取该数据。
* 读：
  1. 行级分享锁, 读完释放。
  2. 对每一个待更新对象维护旧值和将要被设置成的新值，在该事务提交之前，所有其他事务的读取只获得旧值，写事务提交后获得新值。
* 写： 行级独占锁, 事务结束释放。
* 优点： 无 `脏读`，脏写。
* 缺点： `不可重复读`。

3. 可重复读
* 一个事务读取数据，如果该事务尚未提交，其他事务不可以修改该数据。
* 读： 行级分享锁, 事务结束释放。
* 写： 行级独占锁, 事务结束释放。
* 优点： 无 脏读，脏写，不可重复读。
* 缺点： `幻读`。

4. 快照级别隔离
* MVCC（Multi-Version Concurrency Control）
* 只允许读取事务开始前已提交版本的数据。既可以利于并发，又可以减少隔离冲突的一种解决方式。

* 优点：无 脏写，脏读，不可重复读，（只读）幻读。
* 缺点：更新丢失，`写倾斜`（有写的幻读）。
  * 解决方式：
    1. 悲观锁：写锁。
    2. 乐观锁：开始不管，最后冲突解决。

5. 可串行化

* 读： 表级分享锁, 事务结束释放。
* 写： 表级独占锁, 事务结束释放。
* 优点： 无 脏读，更新丢失，不可重复读，幻读。
* 缺点： 串行化，事务并发程度低。

### 参考：
- [https://tech.ipalfish.com/blog/2020/03/26/isolation/](https://tech.ipalfish.com/blog/2020/03/26/isolation/)



